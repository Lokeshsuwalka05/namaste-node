# ğŸš€ Express.js Routing Deep Dive

In this episode, we explored **routing in Express.js** â€” how to handle requests, route patterns, regex usage, and reading params.

---

## ğŸ”¹ Order of Route Handlers Matters

- Express evaluates routes **top to bottom**.
- The **first matching route wins**.

Example:

```js
app.get("/user", (req, res) => res.send("User Route"));
app.use("/user", (req, res) => res.send("Fallback User Route"));
```

ğŸ‘‰ Here, /user will always match the first route (app.get), and the second will never run.

## ğŸ”¹ app.use() vs app.get() vs app.post()

- **app.use()** â†’ Matches all HTTP methods (GET, POST, PUT, DELETE, etc.).
- **app.get()** â†’ Handles only GET requests.
- **app.post()** â†’ Handles only POST requests.

âœ… **Best practice:** use app.get(), app.post(), etc. for clarity instead of a generic app.use().

## ğŸ”¹ Route Patterns in Express

Express allows pattern matching in routes using `?`, `+`, `*`, and `()` (supported in v4 & v5).

**Examples:**

### ? â†’ Optional Character

```js
app.get("/ab?c", (req, res) => res.send("b is optional!"));
```

âœ… **Matches:** /ac, /abc

### + â†’ One or More Repetitions

```js
app.get("/ab+c", (req, res) => res.send("One or many b's allowed!"));
```

âœ… **Matches:** /abc, /abbc, /abbbc

### \* â†’ Wildcard (any characters)

```js
app.get("/ab*c", (req, res) => res.send("Anything in between allowed!"));
```

âœ… **Matches:** /abc, /abXYZc, /ab123c

### () â†’ Grouping

```js
app.get("/a(bc)?d", (req, res) => res.send("Group optional!"));
```

âœ… **Matches:** /ad, /abcd

## ğŸ”¹ Regex in Routes ğŸ’¡

We can use regular expressions directly in routes for advanced matching.

```js
app.get(/a/, (req, res) => res.send("Route has 'a' in it"));
// Matches: /apple, /bat, /cat

app.get(/.*fly$/, (req, res) => res.send("Ends with 'fly'"));
// Matches: /butterfly, /dragonfly
```

## ğŸ”¹ Query Params vs Dynamic Params

### ğŸŸ¢ Query Params â†’ Extra Info / Filters

- **Syntax:** ?key=value
- **Used for:** search, sorting, filtering.

```js
app.get("/products", (req, res) => {
  const { category, sort } = req.query;
  res.send(`Category: ${category}, Sort: ${sort}`);
});
```

ğŸ‘‰ **Request:** /products?category=shoes&sort=price  
ğŸ‘‰ **Response:** Category: shoes, Sort: price

### ğŸŸ¢ Dynamic Params â†’ Unique Resource Identity

- **Syntax:** :param
- **Used for:** fetching a specific resource.

```js
app.get("/products/:id", (req, res) => {
  res.send(`Product ID: ${req.params.id}`);
});
```

ğŸ‘‰ **Request:** /products/123  
ğŸ‘‰ **Response:** Product ID: 123

## ğŸ”¹ Real-World Analogy ğŸ´

Think of a restaurant system:

- **Customer (Client)** â†’ Places an order (request).
- **Waiter (Server)** â†’ Takes the order.
- **Chef (Route Handler)** â†’ Prepares the dish (process request).
- **Waiter â†’ Customer** â†’ Serves the dish (response).

ğŸ‘‰ Exactly how Express routing works!

## ğŸ¯ Key Takeaways

- **Order matters** â†’ first match wins.
- **Use specific methods** (GET/POST) instead of app.use().
- **Route patterns** (?, +, \*, ()) = flexible matching.
- **Regex** = advanced matching superpower.
- **Query Params** = filters / extra info.
- **Dynamic Params** = unique resource identifiers.
